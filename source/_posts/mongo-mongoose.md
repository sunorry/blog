title: 'mongo & mongoose'
tags:
  - 什么关系
categories: []
date: 2016-02-29 13:09:00
---
什么关系篇!
<!-- more -->

## 校验

不想在每次对数据库的操作（插入、更新、查询）都重复校验。

`Mongoose` 通过允许在应用层定义 `schema` 来解决问题，它在保持文档灵活性和易改动的前提下，引入了特定的属性对齐做一定的学术，成为模型。

## 原子性

加入写了个 blog ，用 Express 和 MongoDB 。

A 想编辑文档的标题，与此同时，B 想添加一个标签。他两同时传递一份完整的文档拷贝来进行更新操作，那么只会有一个人成功，另外一个无法对数据库操作失败。

要确保原子性，`MongoDB` 提供了 `$set` 和 `$push`操作符。

```
db.blogposts.update({ _id: <id> }, { $set: { title: 'new Title' } });
db.blogposts.update({ _id: <id> }, { tags: { $push: 'new Tag' } });
```

`Mongoose` 则是通过检查要对文档做的修改，并只修改受影响的字段来解决这个问题。就算是操作的是数组（包括文档数组），原子性依然能够得到保证。

## 安全模式
使用数据库驱动器，操作文档时提供一个可以选的 `options` 参数：
```
app.users.insert( {}, { <options> } );
```
有一个参数 `safe`，它会对数据库进行修改时启动安全模式。

默认情况下，在操作完成后，如果有错误发生，`MongoDB`不会及时通知你。驱动器需要在操作完成后进行一个特殊的函数调用 `db.getLastError`，来验证数据修改是否成功。

`Mongoose` 默认会对所有操作启用安全模式。

## 简单的简介

相比原声的驱动器，`Mongoose` 做的第一个简化就是**它假定绝大部分的应用程序都是用一个数据库，这大大简化了使用方式**。

### 连接数据库
```
Mongoose.connect('mongodb://localhost/my_database');
```
另外，使用 `Mongoose` ，就无需关心链接是否真的已经建立了，因为，它会先把数据库操作指令缓存起来，在连接上数据库以后就会把这些操作发送给 `MongoDB`。**这就意味着,我们无需监听 connection 的回调函数**，连接后就可以直接开始查询数据库了。

参考书籍：《了不起的Node.js》